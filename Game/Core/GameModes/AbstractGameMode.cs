using Game.Core.Board;
using Game.Core.Communication;
using Game.Core.GameModes.Rules;
using Game.Core.Language;
using Game.Core.Network;
using Game.Core.Players;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

namespace Game.Core.GameModes
{
    /// <summary>
    /// A abstract game mode with commonly used methods used in a gamemode.
    /// </summary>
    abstract class AbstractGameMode
    {
        protected Dictionary _dictionary;
        protected TileSchema _tileSchema;
        protected Host _netHost;
        protected PlayerAndBoardCollection _playerAndBoardCollection = new();
        protected Random _rng;
        protected IGameRules _gameRules;

        protected readonly int _numberOfbots;
        protected readonly int _numberOfPlayers;

        /// <summary>
        /// Initialize a new instance of the <see cref="AbstractGameMode"/>
        /// </summary>
        /// <param name="dictionary">Dictionary to use when calculating the score.</param>
        /// <param name="tileSchema">Tileschema to allow players to use.</param>
        /// <param name="networkHost">Network to use when communicating with network players.</param>
        /// <param name="gameRules">Rules to use in gamemode.</param>
        /// <param name="bots">Number of bots to use.</param>
        /// <param name="players">Number of players to allow in game, exluding the host.</param>
        /// <param name="randomizationSeed">Seed to use in part where randomization is used. Set to null to use a random seed.</param>
        public AbstractGameMode(
            Dictionary dictionary,
            TileSchema tileSchema,
            Host networkHost,
            IGameRules gameRules,
            int bots,
            int players,
            int? randomizationSeed)
        {
            _dictionary = dictionary ?? throw new ArgumentNullException(nameof(dictionary));
            _tileSchema = tileSchema ?? throw new ArgumentNullException(nameof(tileSchema));
            _netHost = networkHost ?? throw new ArgumentNullException(nameof(networkHost));
            _gameRules = gameRules ?? throw new ArgumentNullException(nameof(gameRules));
            _numberOfbots = bots;
            _numberOfPlayers = players;
            _rng = randomizationSeed is null ? new Random() : new Random((int)randomizationSeed);
        }

        /// <summary>
        /// Setup the gamemode and allow players to enter, run game until finished,
        /// and cleanup when game is finished.
        /// </summary>
        public virtual void Run()
        {
            Setup();
            GameLoop();
            CleanUp();
        }

        /// <summary>
        /// Create the amount of bots specified by <see cref="_numberOfbots"/> and add
        /// them to <see cref="_playerAndBoardCollection"/>.
        /// </summary>
        /// <remarks>
        /// The bots will be using the board specified in <see cref="BuildBoard()"/> 
        /// and will use the next integer value generated by <see cref="_rng"/> as seed.
        /// </remarks>
        protected virtual void CreateBots()
        {
            for (int i = 0; i < _numberOfbots; i++)
            {
                var board = BuildBoard();
                var seed = _rng.Next();
                var bot = CreateBot(board, seed);
                _playerAndBoardCollection.Add(bot, board);
            }
        }

        /// <summary>
        /// Create a new bot.
        /// </summary>
        /// <param name="board">Board to initialize the bot with.</param>
        /// <param name="seed">Seed to initialize the bot with.</param>
        /// <returns>The created bot.</returns>
        protected virtual BotPlayer CreateBot(StandardBoard board, int seed)
        {
            return new BotPlayer(board, seed);
        }

        /// <summary>
        /// Start the network host.
        /// </summary>
        /// <exception cref="SocketException"></exception>
        protected virtual void StartNetworkHost()
        {
            _netHost.Start();
        }

        /// <summary>
        /// Synchronously wait for the next network player to connect.
        /// </summary>
        /// <returns>The connected player</returns>
        protected virtual NetworkPlayer WaitForNetworkPlayer()
        {
            var netClient = _netHost.WaitForIncomingConnection();
            return new NetworkPlayer(netClient);
        }

        /// <summary>
        /// Displays the board owned by the specified player to him.
        /// </summary>
        /// <param name="player">Player to display hirs board to.</param>
        /// <param name="displayTilePoints">Inidicates wheher the tilepoints should be showm.</param>
        protected virtual void DisplayBoardForPlayer(PlayerBase player, bool displayTilePoints)
        {
            var board = _playerAndBoardCollection[player];
            var boardMessage = new InformationMessage(board.GetBoardAsString(displayTilePoints));
            player.SendMessage(boardMessage);
        }

        /// <summary>
        /// Pick a random player from <see cref="_playerAndBoardCollection"/>.
        /// </summary>
        /// <returns>A player</returns>
        protected virtual PlayerBase PickRandomPlayer()
        {
            var playerIndex = _rng.Next(0, _playerAndBoardCollection.Count);
            var players = _playerAndBoardCollection.Players;
            return players[playerIndex];
        }

        /// <summary>
        /// Request the specified player to pick a tile. The tile returned, exists in the <see cref="_tileSchema"/>
        /// </summary>
        /// <param name="player">The player to request a tile from.</param>
        /// <returns>The picked tile</returns>
        protected virtual Tile LetPlayerPickTile(PlayerBase player)
        {
            return player.PickTile(_tileSchema);
        }

        /// <summary>
        /// Asynchronously request the specified player to pick a tile.
        /// </summary>
        /// <param name="player">The player to request a tile from.</param>
        /// <returns>The picked tile</returns>
        protected Task<Tile> LetPlayerPickTileAsync(PlayerBase player)
        {
            return Task.Run(() => LetPlayerPickTile(player));
        }

        /// <summary>
        /// Let the specified player place a tile on his board.
        /// </summary>
        /// <param name="player">Player to let pick a location for the specifed tile.</param>
        /// <param name="tile">Tile to be placed on player's board.</param>
        protected virtual void LetPlayerPlaceTileOnBoard(PlayerBase player, Tile tile)
        {
            var location = player.PickTileLocation(tile);
            var board = _playerAndBoardCollection[player];
            while (!board.LocationIsPresentOnBoard(location) || !board.LocationIsEmpty(location))
            {
                player.SendMessage(new InformationMessage($"The placement of {tile.Letter} is invalid, please place it somewhere else."));
                location = player.PickTileLocation(tile);
            }

            board.InsertTileAt(location, tile);
            player.SendMessage(new InformationMessage(board.GetBoardAsString(false)));
            if (_playerAndBoardCollection.Players.Count > 1)
            {
                player.SendMessage(new InformationMessage("Waiting for opponents"));
            }
        }

        /// <summary>
        /// Asynchronous let the specified player place a tile on his board.
        /// </summary>
        /// <param name="player">Player to let pick a location for the specifed tile.</param>
        /// <param name="tile">Tile to be placed on player's board.</param>
        protected Task LetPlayerPlaceTileOnBoardAsync(PlayerBase player, Tile tile)
        {
            return Task.Run(() => LetPlayerPlaceTileOnBoard(player, tile));
        }

        /// <summary>
        /// Generate a leaderboard from a list of scores, where the player with the
        /// highest score is on first place.
        /// </summary>
        /// <param name="scores">A list of key-value pairs where the key is a player and the value is the player's score.</param>
        /// <returns>The generated leaderboard</returns>
        protected virtual string GenerateLeaderboard(List<KeyValuePair<PlayerBase, int>> scores)
        {
            var winners = scores.OrderByDescending((s) => s.Value).ToArray();
            var leaderboard = new StringBuilder();
            leaderboard.AppendLine("  Leaderboard  ");
            for (int i = 0; i < winners.Length; i++)
            {
                leaderboard.AppendLine($"{i + 1}. {winners[i].Key.ID} ({winners[i].Value} points)");
            }

            return leaderboard.ToString();
        }

        /// <summary>
        /// Send an information message to all players.
        /// </summary>
        /// <param name="message">Message to send</param>
        protected void SendInformationToAllPlayers(string message)
        {
            foreach (var player in _playerAndBoardCollection.Players)
            {
                var leaderBoardMessage = new InformationMessage(message);
                player.SendMessage(leaderBoardMessage);
            }
        }

        /// <summary>
        /// Send a <see cref="GameHasEndedMessage"/> to all players.
        /// </summary>
        protected void TellAllPLayersGameHasEnded()
        {
            foreach (var player in _playerAndBoardCollection.Players)
            {
                if (player is LocalPlayer) continue;

                player.SendMessage(new GameHasEndedMessage());
            }
        }

        /// <summary>
        /// Disconnect all players and stop <see cref="_netHost"/>.
        /// </summary>
        protected virtual void StopNetworkHost()
        {
            _netHost.DisconnectAllClients();
            _netHost.Stop();
        }

        /// <summary>
        /// Used to setup the game before running the main <see cref="GameLoop"/>.
        /// </summary>
        protected abstract void Setup();

        /// <summary>
        /// Used to run the game mode.
        /// </summary>
        protected abstract void GameLoop();

        /// <summary>
        /// Used to cleanup and release resources when the game has ended.
        /// </summary>
        protected abstract void CleanUp();

        /// <summary>
        /// Used to generate a board.
        /// </summary>
        /// <returns>A generated board</returns>
        protected abstract StandardBoard BuildBoard();
    }
}
